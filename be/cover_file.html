
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tournament_type: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">legend_score/consts/tournament_type/const.go (0.0%)</option>
				
				<option value="file1">legend_score/controllers/auth.go (0.0%)</option>
				
				<option value="file2">legend_score/controllers/line.go (0.0%)</option>
				
				<option value="file3">legend_score/controllers/player_score.go (0.0%)</option>
				
				<option value="file4">legend_score/controllers/rank.go (0.0%)</option>
				
				<option value="file5">legend_score/controllers/response/line_message.go (0.0%)</option>
				
				<option value="file6">legend_score/controllers/response/player.go (0.0%)</option>
				
				<option value="file7">legend_score/controllers/response/player_score.go (0.0%)</option>
				
				<option value="file8">legend_score/controllers/response/rank.go (0.0%)</option>
				
				<option value="file9">legend_score/controllers/response/rank_message.go (0.0%)</option>
				
				<option value="file10">legend_score/controllers/response/tournament.go (0.0%)</option>
				
				<option value="file11">legend_score/controllers/tournament.go (0.0%)</option>
				
				<option value="file12">legend_score/di/controller.go (0.0%)</option>
				
				<option value="file13">legend_score/di/di.go (0.0%)</option>
				
				<option value="file14">legend_score/di/repository.go (0.0%)</option>
				
				<option value="file15">legend_score/di/usecase.go (0.0%)</option>
				
				<option value="file16">legend_score/entities/tournament.go (0.0%)</option>
				
				<option value="file17">legend_score/legend_score.go (0.0%)</option>
				
				<option value="file18">legend_score/infra/database/connection/conn.go (65.0%)</option>
				
				<option value="file19">legend_score/infra/logger/logger.go (0.0%)</option>
				
				<option value="file20">legend_score/infra/server/server.go (0.0%)</option>
				
				<option value="file21">legend_score/repositories/admin_user.go (71.4%)</option>
				
				<option value="file22">legend_score/repositories/mock/player.go (0.0%)</option>
				
				<option value="file23">legend_score/repositories/player.go (71.4%)</option>
				
				<option value="file24">legend_score/repositories/schedule.go (71.4%)</option>
				
				<option value="file25">legend_score/repositories/schedule_detail.go (71.4%)</option>
				
				<option value="file26">legend_score/repositories/tournament.go (71.4%)</option>
				
				<option value="file27">legend_score/repositories/tournament_manage.go (61.5%)</option>
				
				<option value="file28">legend_score/repositories/tournament_score.go (71.4%)</option>
				
				<option value="file29">legend_score/repositories/tournament_score_detail.go (71.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package tournament_type

// Practice 前日練習
const Practice = 1

// Qualifying 予選
const Qualifying = 2

// SemiFinal 準決勝
const SemiFinal = 3

// RoundRobin ラウンドロビン
const RoundRobin = 4

// Final 決勝
const Final = 5

func GetTypeName(t int) string <span class="cov0" title="0">{
        switch t </span>{
        case Practice:<span class="cov0" title="0">
                return "前日練習"</span>
        case Qualifying:<span class="cov0" title="0">
                return "予選"</span>
        case SemiFinal:<span class="cov0" title="0">
                return "準決勝"</span>
        case RoundRobin:<span class="cov0" title="0">
                return "ラウンドロビン"</span>
        case Final:<span class="cov0" title="0">
                return "決勝"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}</pre>
		
		<pre class="file" id="file1" style="display: none">package controllers

import (
        "legend_score/controllers/ci"
        "legend_score/controllers/request"
        "legend_score/infra/logger"
        "legend_score/usecases/ui"
        "github.com/labstack/echo/v4"
        "net/http"
)

type AuthControllerImp struct {
        cu ui.CryptographyUseCase
}

func NewAuthController(cu ui.CryptographyUseCase) ci.AuthController <span class="cov0" title="0">{
        return &amp;AuthControllerImp{
                cu: cu,
        }
}</span>

func (ci *AuthControllerImp) Post(c echo.Context) error <span class="cov0" title="0">{
        var req request.Auth
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">pass, err := ci.cu.DecryptionBase64(req.Password)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">logger.Debug(pass)

        return c.JSON(http.StatusOK, "success")</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "fmt"
        "legend_score/consts/line"
        "legend_score/controllers/ci"
        "legend_score/controllers/response"
        "legend_score/infra/logger"
        "legend_score/usecases/ui"
        "net/http"
        "os"

        "github.com/labstack/echo/v4"
        "github.com/line/line-bot-sdk-go/v8/linebot/messaging_api"
        "github.com/line/line-bot-sdk-go/v8/linebot/webhook"
)

type LineControllerImp struct {
        pu ui.PlayerUseCase
        tu ui.TournamentUseCase
        lu ui.LineUseCase
}

func NewLineController(
        pu ui.PlayerUseCase, tu ui.TournamentUseCase, lu ui.LineUseCase,
) ci.LineController <span class="cov0" title="0">{
        return &amp;LineControllerImp{
                pu: pu,
                tu: tu,
                lu: lu,
        }
}</span>

func (ci *LineControllerImp) Message(c echo.Context) error <span class="cov0" title="0">{
        bot, err := messaging_api.NewMessagingApiAPI(
                os.Getenv("CHANNEL_TOKEN"),
        )

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                return c.JSON(http.StatusInternalServerError, "")
        }</span>

        <span class="cov0" title="0">fmt.Println("bot作成成功")

        // リクエスト処理
        cb, berr := webhook.ParseRequest(os.Getenv("CHANNEL_SECRET"), c.Request())
        if berr != nil </span><span class="cov0" title="0">{
                fmt.Println(berr.Error())
                return c.JSON(http.StatusInternalServerError, "test2")
        }</span>

        <span class="cov0" title="0">fmt.Println("cb作成成功")

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                return c.JSON(http.StatusInternalServerError, "test3")
        }</span>

        <span class="cov0" title="0">for _, event := range cb.Events </span><span class="cov0" title="0">{
                fmt.Println(event.GetType())

                switch e := event.(type) </span>{
                case webhook.MessageEvent:<span class="cov0" title="0">
                        ti, err := ci.tu.GetExecInfo()

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                                return c.JSON(http.StatusInternalServerError, "")
                        }</span>

                        <span class="cov0" title="0">ty, p, err := ci.lu.GetAcceptText(e)

                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err.Error())
                                return c.JSON(http.StatusInternalServerError, "判定失敗")
                        }</span>

                        <span class="cov0" title="0">switch ty </span>{
                        case line.RankType:<span class="cov0" title="0">
                                rci := response.RankMessage{}
                                scoreList, err := ci.tu.GetTournamentScore(ti)

                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Error(err.Error())
                                        return c.JSON(http.StatusInternalServerError, "スコア取得失敗")
                                }</span>

                                <span class="cov0" title="0">_, err = bot.ReplyMessage(
                                        &amp;messaging_api.ReplyMessageRequest{
                                                ReplyToken: e.ReplyToken,
                                                Messages: []messaging_api.MessageInterface{
                                                        &amp;messaging_api.FlexMessage{
                                                                AltText:  ti.CreateAltText(),
                                                                Contents: rci.CreateScoreResponse(scoreList),
                                                        },
                                                },
                                        },
                                )</span>
                        case line.PlayerScoreType:<span class="cov0" title="0">
                                fci := response.ScoreMessage{}
                                ti.Player = p
                                ps, err := ci.pu.GetPlayerScore(ti)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err.Error())
                                        return c.JSON(http.StatusInternalServerError, "test4")
                                }</span>
                                <span class="cov0" title="0">logger.Debug("PlayerScore取得成功")

                                _, err = bot.ReplyMessage(
                                        &amp;messaging_api.ReplyMessageRequest{
                                                ReplyToken: e.ReplyToken,
                                                Messages: []messaging_api.MessageInterface{
                                                        &amp;messaging_api.FlexMessage{
                                                                AltText:  ti.CreateAltText(),
                                                                Contents: fci.CreateResponse(ps),
                                                        },
                                                },
                                        },
                                )

                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println(err.Error())
                                        return c.JSON(http.StatusInternalServerError, "")
                                }</span>

                        }
                }
        }

        <span class="cov0" title="0">return c.JSON(http.StatusOK, "success")</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package controllers

import (
        "legend_score/controllers/ci"
        "legend_score/controllers/request"
        "legend_score/controllers/response"
        "legend_score/infra/logger"
        "legend_score/usecases/ui"
        "github.com/labstack/echo/v4"
        "net/http"
)

type PlayerScoreControllerImp struct {
        tu ui.TournamentUseCase
        pu ui.PlayerUseCase
}

func NewPlayerScoreController(
        tu ui.TournamentUseCase, pu ui.PlayerUseCase,
) ci.PlayerScoreController <span class="cov0" title="0">{
        return &amp;PlayerScoreControllerImp{
                tu: tu,
                pu: pu,
        }
}</span>

func (ci *PlayerScoreControllerImp) Get(c echo.Context) error <span class="cov0" title="0">{
        var req request.PlayerScore
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">ti, err := ci.tu.GetExecInfo()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">p, err := ci.pu.GetPlayerByID(req.PlayerID)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">ti.Player = p[0]

        ps, err := ci.pu.GetPlayerScore(ti)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">res := response.PlayerScoreResponse{}
        res.CreateResponse(ps)

        return c.JSONPretty(http.StatusOK, res, "")</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "legend_score/controllers/ci"
        "legend_score/controllers/request"
        "legend_score/controllers/response"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/usecases/ui"
        "github.com/labstack/echo/v4"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "net/http"
)

type RankControllerImp struct {
        ru ui.RankUseCase
        tu ui.TournamentUseCase
}

func NewRankController(
        ru ui.RankUseCase,
        tu ui.TournamentUseCase,
) ci.RankController <span class="cov0" title="0">{
        return &amp;RankControllerImp{
                ru: ru,
                tu: tu,
        }
}</span>

func (ci *RankControllerImp) Get(c echo.Context) error <span class="cov0" title="0">{
        var req request.RankRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">rankList, err := ci.ru.GetScore(req)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">conditionList := []qm.QueryMod{
                models.ScheduleWhere.ID.EQ(req.ScheduleID),
                models.ScheduleWhere.TounamentID.EQ(req.ID),
        }

        sl, err := ci.tu.GetSchedule(conditionList)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusInternalServerError)
        }</span>

        <span class="cov0" title="0">res := response.RankResponse{}
        res.CreateResponse(rankList, sl[0].BorderCount.Int)

        return c.JSONPretty(http.StatusOK, res, "")</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package response

import (
        "fmt"
        "legend_score/consts/player"
        "legend_score/consts/score_detail"
        "legend_score/consts/tournament_type"
        "legend_score/entities"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "github.com/line/line-bot-sdk-go/v8/linebot/messaging_api"
        "strconv"
)

type ScoreMessage struct {
        Hero *messaging_api.FlexImage
        Body *messaging_api.FlexBox
}

func (f *ScoreMessage) CreateResponse(ps *entities.PlayerScore) messaging_api.FlexBubble <span class="cov0" title="0">{
        f.CreateHero(ps.Player)
        f.CreateBody(ps)

        fmt.Println("test")
        res := messaging_api.FlexBubble{
                Hero: f.Hero,
                Body: f.Body,
        }

        return res
}</span>

func (f *ScoreMessage) CreateHero(p *models.Player) <span class="cov0" title="0">{
        hero := messaging_api.FlexImage{}
        if p.ImageURL.Valid </span><span class="cov0" title="0">{
                hero.Url = p.ImageURL.String
        }</span> else<span class="cov0" title="0"> {
                hero.Url = player.NoImageURL
        }</span>

        <span class="cov0" title="0">hero.AspectRatio = "15:20"
        hero.AspectMode = messaging_api.FlexImageASPECT_MODE_COVER
        hero.Size = "3xl"

        f.Hero = &amp;hero</span>
}

func (f *ScoreMessage) CreateBody(ps *entities.PlayerScore) <span class="cov0" title="0">{
        body := messaging_api.FlexBox{}

        body.Layout = messaging_api.FlexBoxLAYOUT_VERTICAL

        contents := []messaging_api.FlexComponentInterface{}
        contents = append(contents, f.CreatePlayerInfo(ps))

        sList := ps.Score
        for _, s := range sList </span><span class="cov0" title="0">{
                contents = append(contents, f.CreateRankInfo(s))
                contents = append(contents, f.CreateScoreInfo(s))
        }</span>

        <span class="cov0" title="0">body.Contents = contents

        f.Body = &amp;body</span>
}

func (f *ScoreMessage) CreatePlayerInfo(ps *entities.PlayerScore) *messaging_api.FlexText <span class="cov0" title="0">{
        ft := messaging_api.FlexText{}

        ft.Text = ps.Player.Name
        ft.Weight = messaging_api.FlexTextWEIGHT_BOLD
        ft.Size = "xl"
        ft.Align = messaging_api.FlexTextALIGN_CENTER

        return &amp;ft
}</span>

func (f *ScoreMessage) CreateRankInfo(s *entities.TournamentScore) *messaging_api.FlexText <span class="cov0" title="0">{
        ft := messaging_api.FlexText{}

        ft.Text = strconv.Itoa(s.Score.Rank.Int) + "位（" + strconv.Itoa(s.Score.TotalScore) + "pin)"
        ft.Size = "md"
        ft.Margin = "md"
        ft.Align = messaging_api.FlexTextALIGN_CENTER
        ft.Color = "#4646ff"

        return &amp;ft
}</span>

func (f *ScoreMessage) CreateScoreInfo(s *entities.TournamentScore) *messaging_api.FlexBox <span class="cov0" title="0">{
        box := messaging_api.FlexBox{}

        box.Layout = messaging_api.FlexBoxLAYOUT_VERTICAL
        box.Margin = "lg"
        box.Spacing = "sm"

        var scores []messaging_api.FlexComponentInterface
        scores = append(scores, f.CreateRank(s))

        logger.Debug("スコア詳細作成開始")

        slines := f.createSLines(s.Schedule.TotalCount.Int)

        for _, sl := range slines </span><span class="cov0" title="0">{
                sbox := messaging_api.FlexBox{
                        Layout: messaging_api.FlexBoxLAYOUT_HORIZONTAL,
                }

                for _, i := range sl </span><span class="cov0" title="0">{
                        t := messaging_api.FlexText{
                                Align: messaging_api.FlexTextALIGN_CENTER,
                                Flex:  1,
                        }

                        if len(s.ScoreDetail) &lt;= i </span><span class="cov0" title="0">{
                                t.Text = "-"
                                t.Color = score_detail.MinusColor
                        }</span> else<span class="cov0" title="0"> {
                                t.Text = strconv.Itoa(s.ScoreDetail[i].Score)

                                if s.ScoreDetail[i].Score &gt;= score_detail.PlusScore </span><span class="cov0" title="0">{
                                        t.Color = score_detail.PlusColor
                                }</span> else<span class="cov0" title="0"> {
                                        t.Color = score_detail.MinusColor
                                }</span>
                        }

                        <span class="cov0" title="0">sbox.Contents = append(sbox.Contents, &amp;t)</span>
                }

                <span class="cov0" title="0">scores = append(scores, &amp;sbox)</span>
        }

        <span class="cov0" title="0">box.Contents = scores

        return &amp;box</span>
}

func (f *ScoreMessage) createSLines(gc int) [][]int <span class="cov0" title="0">{
        result := [][]int{}
        var base []int

        for i := 0; i &lt; gc; i++ </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        base = []int{i}
                        continue</span>
                } else<span class="cov0" title="0"> if i%6 == 0 </span><span class="cov0" title="0">{
                        result = append(result, base)
                        base = []int{i}
                        continue</span>
                } else<span class="cov0" title="0"> {
                        base = append(base, i)
                }</span>
        }

        <span class="cov0" title="0">if len(base) &gt; 0 </span><span class="cov0" title="0">{
                result = append(result, base)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func (f *ScoreMessage) CreateRank(s *entities.TournamentScore) *messaging_api.FlexText <span class="cov0" title="0">{
        name := tournament_type.GetTypeName(s.Schedule.TounamentType)

        ft := messaging_api.FlexText{
                Text: name + "(" + strconv.Itoa(s.Score.Rank.Int) + "位)",
                Size: "sm",
                Flex: 1,
        }

        return &amp;ft
}</pre>
		
		<pre class="file" id="file6" style="display: none">package response

import "legend_score/infra/database/models"

type PlayerResponse struct {
        PlayerID    int    `json:"player_id"`
        Name        string `json:"name"`
        PlayerImage string `json:"player_image"`
}

func (r *PlayerResponse) CreateResponse(p *models.Player) <span class="cov0" title="0">{
        r.PlayerID = p.ID
        r.Name = p.Name
        r.PlayerImage = p.ImageURL.String
}</pre>
		
		<pre class="file" id="file7" style="display: none">package response

import (
        "legend_score/consts/tournament_type"
        "legend_score/entities"
)

type PlayerScoreResponse struct {
        Player PlayerResponse `json:"player"`
        Scores ScoresResponse `json:"scores"`
}

type ScoresResponse struct {
        Qualifying TimeRank `json:"qualifying"`
        SemiFinal  TimeRank `json:"semi_final"`
        RoundRobin TimeRank `json:"round_robin"`
        Final      TimeRank `json:"final"`
}

type TimeRank struct {
        Rank        int             `json:"rank"`
        TotalScore  int             `json:"total_score"`
        ScoreDetail []ScoreResponse `json:"score_detail"`
}

func (r *PlayerScoreResponse) CreateResponse(ps *entities.PlayerScore) <span class="cov0" title="0">{
        r.Player.CreateResponse(ps.Player)

        scorelist := ps.Score

        for _, ts := range scorelist </span><span class="cov0" title="0">{
                var rsl []ScoreResponse

                for _, sd := range ts.ScoreDetail </span><span class="cov0" title="0">{
                        s := ScoreResponse{
                                GameCount:  sd.GameCount.Int,
                                Score:      sd.Score,
                                BonusPoint: sd.BounasPoint.Int,
                        }

                        rsl = append(rsl, s)
                }</span>

                <span class="cov0" title="0">if ts.Schedule.TounamentType == tournament_type.Qualifying </span><span class="cov0" title="0">{
                        r.Scores.Qualifying.ScoreDetail = rsl
                        r.Scores.Qualifying.Rank = ts.Score.Rank.Int
                        r.Scores.Qualifying.TotalScore = ts.Score.TotalScore
                }</span>
        }
}</pre>
		
		<pre class="file" id="file8" style="display: none">package response

import "legend_score/infra/database/models"

type RankResponse struct {
        RankList []Rank `json:"rank_list"`
}

type Rank struct {
        PlayerID     int    `json:"player_id"`
        Name         string `json:"name"`
        PlayerImage  string `json:"player_image"`
        TournamentID int    `json:"tournament_id"`
        TotalScore   int    `json:"total_score"`
        Rank         int    `json:"rank"`
        Border       bool   `json:"border"`
}

func (res *RankResponse) CreateResponse(rl models.TounamentScoreSlice, b int) <span class="cov0" title="0">{
        var rs []Rank

        for _, r := range rl </span><span class="cov0" title="0">{
                pr := Rank{
                        PlayerID:     r.PlayerID,
                        Name:         r.R.Player.Name,
                        PlayerImage:  r.R.Player.ImageURL.String,
                        TournamentID: r.TounamentID,
                        TotalScore:   r.TotalScore,
                        Rank:         r.Rank.Int,
                        Border:       false,
                }

                if r.Rank.Int &lt;= b </span><span class="cov0" title="0">{
                        pr.Border = true
                }</span>

                <span class="cov0" title="0">rs = append(rs, pr)</span>
        }

        <span class="cov0" title="0">res.RankList = rs</span>
}</pre>
		
		<pre class="file" id="file9" style="display: none">package response

import (
        "legend_score/consts/line"
        "legend_score/infra/database/models"
        "github.com/line/line-bot-sdk-go/v8/linebot/messaging_api"
        "strconv"
)

type RankMessage struct {
        Hero *messaging_api.FlexImage
        Body *messaging_api.FlexBox
}

func (f *RankMessage) CreateScoreResponse(sl models.TounamentScoreSlice) messaging_api.FlexCarousel <span class="cov0" title="0">{
        first := []*models.TounamentScore{}
        second := []*models.TounamentScore{}

        jd := len(sl)
        for i, s := range sl </span><span class="cov0" title="0">{
                if i &gt; jd/2 </span><span class="cov0" title="0">{
                        second = append(second, s)
                }</span> else<span class="cov0" title="0"> {
                        first = append(first, s)
                }</span>
        }

        <span class="cov0" title="0">contents := []messaging_api.FlexBubble{}
        contents = append(contents, f.CreateBubble(first))

        if len(second) &gt; 0 </span><span class="cov0" title="0">{
                contents = append(contents, f.CreateBubble(second))
        }</span>

        <span class="cov0" title="0">res := messaging_api.FlexCarousel{
                Contents: contents,
        }

        return res</span>
}

func (f *RankMessage) CreateBubble(sList []*models.TounamentScore) messaging_api.FlexBubble <span class="cov0" title="0">{
        body := f.CreateBubbleBody(sList)

        res := messaging_api.FlexBubble{
                Body: body,
        }

        return res
}</span>

func (f *RankMessage) CreateBubbleBody(sList []*models.TounamentScore) *messaging_api.FlexBox <span class="cov0" title="0">{
        var boxContent []messaging_api.FlexComponentInterface

        for _, s := range sList </span><span class="cov0" title="0">{
                var content []messaging_api.FlexComponentInterface
                player := *s.R.GetPlayer()

                action := messaging_api.UriAction{
                        Uri:   "https://6ef1-240f-76-9009-1-ed3f-d013-5d48-c989.ngrok-free.app/player_score/" + strconv.Itoa(s.TounamentID) + "/" + strconv.Itoa(s.PlayerID),
                        Label: strconv.Itoa(s.Rank.Int) + "位 " + player.Name + " (" + strconv.Itoa(s.TotalScore) + ")",
                }

                b := messaging_api.FlexButton{
                        Height: messaging_api.FlexButtonHEIGHT_SM,
                        Flex:   3,
                        Style:  messaging_api.FlexButtonSTYLE_LINK,
                        Action: &amp;action,
                }

                content = append(content, b)

                actionDetail := messaging_api.MessageAction{
                        Label: "詳細",
                        Text:  line.PlayerScore + " " + player.Name,
                }

                detailButton := messaging_api.FlexButton{
                        Height: messaging_api.FlexButtonHEIGHT_SM,
                        Flex:   1,
                        Style:  messaging_api.FlexButtonSTYLE_SECONDARY,
                        Action: &amp;actionDetail,
                }

                content = append(content, detailButton)

                ps := messaging_api.FlexBox{
                        Layout:   messaging_api.FlexBoxLAYOUT_HORIZONTAL,
                        Margin:   "md",
                        Contents: content,
                }
                boxContent = append(boxContent, &amp;ps)
        }</span>

        <span class="cov0" title="0">box := messaging_api.FlexBox{
                Layout:   messaging_api.FlexBoxLAYOUT_VERTICAL,
                Contents: boxContent,
        }

        return &amp;box</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package response

import (
        "legend_score/consts/game_status"
        "legend_score/infra/database/models"
)

type TournamentResponse struct {
        Name     string             `json:"name"`
        Schedule []ScheduleResponse `json:"schedule"`
}

type ScheduleResponse struct {
        ID        int    `json:"id"`
        Name      string `json:"name"`
        GameCount int    `json:"game_count"`
        Status    int    `json:"status"`
}

func (res *TournamentResponse) SetParam(t *models.Tounament, tm *models.TounamentManage, sl models.ScheduleSlice) <span class="cov0" title="0">{
        res.Name = t.Name

        var srl []ScheduleResponse
        for _, s := range sl </span><span class="cov0" title="0">{
                sr := ScheduleResponse{
                        ID:        s.ID,
                        Name:      s.R.ScheduleTounamentType.Name.String,
                        GameCount: s.TotalCount.Int,
                        Status:    game_status.NoExec,
                }

                if s.ID == tm.ScheduleID.Int </span><span class="cov0" title="0">{
                        sr.Status = game_status.Exec
                }</span> else<span class="cov0" title="0"> if s.ID &lt; tm.ScheduleID.Int </span><span class="cov0" title="0">{
                        sr.Status = game_status.End
                }</span>
                <span class="cov0" title="0">srl = append(srl, sr)</span>
        }

        <span class="cov0" title="0">res.Schedule = srl</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package controllers

import (
        "legend_score/controllers/ci"
        "legend_score/controllers/request"
        "legend_score/controllers/response"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/usecases/ui"
        "github.com/labstack/echo/v4"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
        "net/http"
)

type TournamentControllerImp struct {
        tu ui.TournamentUseCase
}

func NewTournamentController(
        tu ui.TournamentUseCase,
) ci.TournamentController <span class="cov0" title="0">{
        return &amp;TournamentControllerImp{
                tu: tu,
        }
}</span>

func (ci *TournamentControllerImp) Get(c echo.Context) error <span class="cov0" title="0">{
        var req request.Tournament
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusBadRequest)
        }</span>

        <span class="cov0" title="0">conditionList := []qm.QueryMod{
                models.TounamentWhere.ID.EQ(req.ID),
        }

        tl, err := ci.tu.GetTournament(conditionList)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusInternalServerError)
        }</span>

        <span class="cov0" title="0">if len(tl) != 1 </span><span class="cov0" title="0">{
                logger.Error("正常に取得できませんでした。")
                return echo.NewHTTPError(http.StatusInternalServerError)
        }</span>

        <span class="cov0" title="0">tm, sl, err := ci.tu.GetTournamentSchedule(req.ID)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return echo.NewHTTPError(http.StatusInternalServerError)
        }</span>

        <span class="cov0" title="0">if tm == nil || len(sl) == 0 </span><span class="cov0" title="0">{
                logger.Error("正常に取得できませんでした")
                return echo.NewHTTPError(http.StatusInternalServerError)
        }</span>

        <span class="cov0" title="0">res := response.TournamentResponse{}
        res.SetParam(tl[0], tm, sl)

        return c.JSONPretty(http.StatusOK, res, "")</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package di

import (
        "legend_score/controllers"

        "go.uber.org/dig"
)

func provideController(c *dig.Container) <span class="cov0" title="0">{
        setProvide(c, controllers.NewAuthController)
        setProvide(c, controllers.NewLineController)
        setProvide(c, controllers.NewTournamentController)
        setProvide(c, controllers.NewRankController)
        setProvide(c, controllers.NewPlayerScoreController)
}</pre>
		
		<pre class="file" id="file13" style="display: none">package di

import (
        "legend_score/infra/database/connection"
        "legend_score/infra/logger"
        "legend_score/infra/server"

        "go.uber.org/dig"
)

// BuildContainer
// DI注入メイン処理
func BuildContainer(c *dig.Container) <span class="cov0" title="0">{
        setProvide(c, server.NewServer)
        setProvide(c, connection.NewConnection)
        provideController(c)
        provideUseCase(c)
        provideRepository(c)
}</span>

func setProvide(c *dig.Container, i any) <span class="cov0" title="0">{
        if err := c.Provide(i); err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package di

import (
        "legend_score/repositories"

        "go.uber.org/dig"
)

func provideRepository(c *dig.Container) <span class="cov0" title="0">{
        setProvide(c, repositories.NewPlayerRepository)
        setProvide(c, repositories.NewTournamentRepository)
        setProvide(c, repositories.NewTournamentManageRepository)
        setProvide(c, repositories.NewScheduleRepository)
        setProvide(c, repositories.NewScheduleDetailRepository)
        setProvide(c, repositories.NewTournamentScoreRepository)
        setProvide(c, repositories.NewTournamentScoreDetailRepository)
        setProvide(c, repositories.NewAdminUserRepository)
}</pre>
		
		<pre class="file" id="file15" style="display: none">package di

import (
        "legend_score/usecases"

        "go.uber.org/dig"
)

func provideUseCase(c *dig.Container) <span class="cov0" title="0">{
        setProvide(c, usecases.NewPlayerUseCase)
        setProvide(c, usecases.NewTournamentUseCase)
        setProvide(c, usecases.NewLineUseCase)
        setProvide(c, usecases.NewRankUseCase)
        setProvide(c, usecases.NewCyptographyUseCase)
        setProvide(c, usecases.NewAuthUseCase)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package entities

import (
        "legend_score/consts/tournament_type"
        "legend_score/infra/database/models"
        "strconv"
)

type TournamentInfo struct {
        Player          *models.Player
        Tournament      *models.Tounament
        Schedules       models.ScheduleSlice
        ScheduleDetails models.ScheduleDetailSlice
        ExecTournament  *ExecTournament
}

func (ti *TournamentInfo) CreateAltText() string <span class="cov0" title="0">{
        tn := tournament_type.GetTypeName(ti.ExecTournament.Schedule.TounamentType)
        gc := ti.ExecTournament.TounamentMange.GameCount.Int

        return tn + " " + strconv.Itoa(gc) + "ゲーム時点"
}</span>

type ExecTournament struct {
        Tournament      models.Tounament        `boil:",bind"`
        Schedule        models.Schedule         `boil:",bind"`
        ScheduleDetails models.ScheduleDetail   `boil:",bind"`
        TounamentMange  *models.TounamentManage `boil:",bind"`
}</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "legend_score/di"
        "legend_score/infra/server"

        "go.uber.org/dig"
)

func main() <span class="cov0" title="0">{
        c := dig.New()

        di.BuildContainer(c)
        err := c.Invoke(func(s *server.Server) </span><span class="cov0" title="0">{
                s.Start()
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}</pre>
		
		<pre class="file" id="file18" style="display: none">package connection

import (
        "database/sql"
        "fmt"
        "legend_score/infra/logger"
        "github.com/volatiletech/sqlboiler/v4/boil"
        "os"
        "time"

        "github.com/go-sql-driver/mysql"
        "github.com/joho/godotenv"
)

type Connection struct {
        Conn *sql.DB
}

func NewConnection() *Connection <span class="cov8" title="1">{
        c, err := getConnection()

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return &amp;Connection{Conn: c}</span>
}

// getConnection
// DB接続
func getConnection() (*sql.DB, error) <span class="cov8" title="1">{
        jst, err := time.LoadLocation("Asia/Tokyo")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">err = godotenv.Load(fmt.Sprintf("/go/src/app/%s.env", os.Getenv("GO_ENV")))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">conf := mysql.Config{
                DBName:               os.Getenv("DATABASE_NAME"),
                User:                 os.Getenv("DATABASE_USER"),
                Passwd:               os.Getenv("DATABASE_PASS"),
                Addr:                 os.Getenv("DATABASE_ADDR"),
                Net:                  "tcp",
                Collation:            "utf8mb4_unicode_ci",
                Loc:                  jst,
                ParseTime:            true,
                AllowNativePasswords: true,
        }

        conn, err := sql.Open("mysql", conf.FormatDSN())

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">boil.SetDB(conn)
        boil.DebugMode = true

        return conn, nil</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package logger

import (
        "fmt"
        "log/slog"
        "os"
        "runtime"
)

// Debug
// デバックモード時のログ出力
func Debug(msg string) <span class="cov0" title="0">{
        logger := slog.New(createJSONHandler())
        _, file, line, _ := runtime.Caller(1)
        logger.Debug(msg, "path", fmt.Sprintf("%s:%d", file, line))
}</span>

// Info
// infoレベルのログ出力
func Info(msg string) <span class="cov0" title="0">{
        logger := slog.New(createJSONHandler())
        _, file, line, _ := runtime.Caller(1)
        logger.Info(msg, "path", fmt.Sprintf("%s:%d", file, line))
}</span>

func Error(msg string) <span class="cov0" title="0">{
        logger := slog.New(createJSONHandler())
        _, file, line, _ := runtime.Caller(1)
        logger.Error(msg, "path", fmt.Sprintf("%s:%d", file, line))
}</span>

func createJSONHandler() *slog.JSONHandler <span class="cov0" title="0">{
        ops := slog.HandlerOptions{
                Level: slog.LevelDebug,
        }

        h := slog.NewJSONHandler(os.Stdout, &amp;ops)

        return h
}</pre>
		
		<pre class="file" id="file20" style="display: none">package server

import (
        "fmt"
        "legend_score/controllers/ci"
        "legend_score/infra/logger"
        "os"

        "github.com/joho/godotenv"

        "github.com/labstack/echo/v4"
        "go.uber.org/dig"
)

type Server struct {
        echo        *echo.Echo
        Line        ci.LineController
        Tournament  ci.TournamentController
        Rank        ci.RankController
        PlayerScore ci.PlayerScoreController
        Auth        ci.AuthController
}

type inServer struct {
        dig.In
        Line        ci.LineController
        Tournament  ci.TournamentController
        Rank        ci.RankController
        PlayerScore ci.PlayerScoreController
        Auth        ci.AuthController
}

func NewServer(s inServer) *Server <span class="cov0" title="0">{
        return &amp;Server{
                Line:        s.Line,
                Tournament:  s.Tournament,
                Rank:        s.Rank,
                PlayerScore: s.PlayerScore,
                Auth:        s.Auth,
        }
}</span>

func (s *Server) Start() <span class="cov0" title="0">{
        s.echo = echo.New()
        s.routing()

        err := godotenv.Load(fmt.Sprintf("/go/src/app/%s.env", os.Getenv("GO_ENV")))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
        }</span>

        <span class="cov0" title="0">s.echo.Logger.Fatal(s.echo.Start(":1323"))</span>
}

func (s *Server) routing() <span class="cov0" title="0">{
        s.echo.POST("/line/message", s.Line.Message)

        api := s.echo.Group("/api")
        v := api.Group("/v1")

        v.GET("/tournament/:tournament_id", s.Tournament.Get)

        v.GET("/rank/:tournament_id/:schedule_id", s.Rank.Get)

        v.GET("/player_score/:tournament_id/:player_id", s.PlayerScore.Get)

        v.POST("/admin/auth", s.Auth.Post)
}</pre>
		
		<pre class="file" id="file21" style="display: none">package repositories

import (
        "context"
        "legend_score/infra/database/connection"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/repositories/ri"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type AdminUserRepositoryImp struct {
        conn *connection.Connection
}

func NewAdminUserRepository(conn *connection.Connection) ri.AdminUserRepository <span class="cov8" title="1">{
        return &amp;AdminUserRepositoryImp{
                conn: conn,
        }
}</span>

func (r *AdminUserRepositoryImp) GetAdminUser(search []qm.QueryMod) (models.AdminUserSlice, error) <span class="cov8" title="1">{
        ctx := context.Background()

        aus, err := models.AdminUsers(search...).All(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return aus, nil</span>
}</pre>
		
		<pre class="file" id="file22" style="display: none">package mock

import (
        "legend_score/infra/database/models"

        "github.com/stretchr/testify/mock"
        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type MockPlayerRepository struct {
        mock.Mock
}

func (m *MockPlayerRepository) GetPlayers(search []qm.QueryMod) (models.PlayerSlice, error) <span class="cov0" title="0">{
        ret := m.Called(search)
        return ret.Get(0).(models.PlayerSlice), ret.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package repositories

import (
        "context"
        "legend_score/infra/database/connection"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/repositories/ri"

        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type PlayerRepositoryImp struct {
        conn *connection.Connection
}

func NewPlayerRepository(conn *connection.Connection) ri.PlayerRepository <span class="cov8" title="1">{
        return &amp;PlayerRepositoryImp{
                conn: conn,
        }
}</span>

func (r *PlayerRepositoryImp) GetPlayers(search []qm.QueryMod) (models.PlayerSlice, error) <span class="cov8" title="1">{
        ctx := context.Background()

        players, err := models.Players(search...).All(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return players, nil</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">package repositories

import (
        "context"
        "legend_score/infra/database/connection"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/repositories/ri"

        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type ScheduleRepositoryImp struct {
        conn *connection.Connection
}

func NewScheduleRepository(conn *connection.Connection) ri.ScheduleRepository <span class="cov8" title="1">{
        return &amp;ScheduleRepositoryImp{
                conn: conn,
        }
}</span>

func (r *ScheduleRepositoryImp) GetSchedule(search []qm.QueryMod) (models.ScheduleSlice, error) <span class="cov8" title="1">{
        ctx := context.Background()

        s, err := models.Schedules(search...).All(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return s, nil</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">package repositories

import (
        "context"
        "legend_score/infra/database/connection"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/repositories/ri"

        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type ScheduleDetailRepositoryImp struct {
        conn *connection.Connection
}

func NewScheduleDetailRepository(conn *connection.Connection) ri.ScheduleDetailRepository <span class="cov8" title="1">{
        return &amp;ScheduleDetailRepositoryImp{
                conn: conn,
        }
}</span>

func (r *ScheduleDetailRepositoryImp) GetScheduleDetail(search []qm.QueryMod) (models.ScheduleDetailSlice, error) <span class="cov8" title="1">{
        ctx := context.Background()

        sd, err := models.ScheduleDetails(search...).All(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return sd, nil</span>
}</pre>
		
		<pre class="file" id="file26" style="display: none">package repositories

import (
        "context"
        "legend_score/infra/database/connection"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/repositories/ri"

        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type TournamentRepositoryImp struct {
        conn *connection.Connection
}

func NewTournamentRepository(conn *connection.Connection) ri.TournamentRepository <span class="cov8" title="1">{
        return &amp;TournamentRepositoryImp{
                conn: conn,
        }
}</span>

func (r *TournamentRepositoryImp) GetTournament(search []qm.QueryMod) (models.TounamentSlice, error) <span class="cov8" title="1">{
        ctx := context.Background()

        t, err := models.Tounaments(search...).All(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return t, nil</span>
}</pre>
		
		<pre class="file" id="file27" style="display: none">package repositories

import (
        "context"
        "legend_score/entities"
        "legend_score/infra/database/connection"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/repositories/ri"

        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type TournamentManageRepositoryImp struct {
        conn *connection.Connection
        sdr  ri.ScheduleDetailRepository
}

func NewTournamentManageRepository(conn *connection.Connection, sdr ri.ScheduleDetailRepository) ri.TournamentManageRepository <span class="cov8" title="1">{
        return &amp;TournamentManageRepositoryImp{
                conn: conn,
                sdr:  sdr,
        }
}</span>

func (r *TournamentManageRepositoryImp) ExecTournament(search []qm.QueryMod) (*entities.ExecTournament, error) <span class="cov8" title="1">{
        ctx := context.Background()
        et := entities.ExecTournament{}

        search = append(search, qm.Load(models.TounamentManageRels.Tounament))
        search = append(search, qm.Load(models.TounamentManageRels.Schedule))

        tm, err := models.TounamentManages(search...).One(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">et.TounamentMange = tm
        et.Tournament = *tm.R.GetTounament()
        et.Schedule = *tm.R.GetSchedule()

        if tm.ScheduleDetailID.Valid </span><span class="cov8" title="1">{
                searchList := []qm.QueryMod{
                        models.ScheduleDetailWhere.ID.EQ(tm.ScheduleDetailID.Int),
                }

                sdList, err := r.sdr.GetScheduleDetail(searchList)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err.Error())
                        return nil, err
                }</span>

                <span class="cov8" title="1">et.ScheduleDetails = *sdList[0]</span>
        }

        <span class="cov8" title="1">return &amp;et, nil</span>
}

func (r *TournamentManageRepositoryImp) GetTournamentManage(search []qm.QueryMod) (*models.TounamentManage, error) <span class="cov0" title="0">{
        ctx := context.Background()
        tm, err := models.TounamentManages(search...).One(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">return tm, nil</span>
}</pre>
		
		<pre class="file" id="file28" style="display: none">package repositories

import (
        "context"
        "legend_score/infra/database/connection"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/repositories/ri"

        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type TournamentScoreRepositoryImp struct {
        conn *connection.Connection
}

func NewTournamentScoreRepository(conn *connection.Connection) ri.TournamentScoreRepository <span class="cov8" title="1">{
        return &amp;TournamentScoreRepositoryImp{
                conn: conn,
        }
}</span>

func (r *TournamentScoreRepositoryImp) GetTournamentScore(search []qm.QueryMod) (models.TounamentScoreSlice, error) <span class="cov8" title="1">{
        ctx := context.Background()

        ts, err := models.TounamentScores(search...).All(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return ts, nil</span>
}</pre>
		
		<pre class="file" id="file29" style="display: none">package repositories

import (
        "context"
        "legend_score/infra/database/connection"
        "legend_score/infra/database/models"
        "legend_score/infra/logger"
        "legend_score/repositories/ri"

        "github.com/volatiletech/sqlboiler/v4/queries/qm"
)

type TournamentScoreDetailRepositoryImp struct {
        conn *connection.Connection
}

func NewTournamentScoreDetailRepository(conn *connection.Connection) ri.TournamentScoreDetailRepository <span class="cov8" title="1">{
        return &amp;TournamentScoreDetailRepositoryImp{
                conn: conn,
        }
}</span>

func (r *TournamentScoreDetailRepositoryImp) GetTournamentScoreDetail(search []qm.QueryMod) (models.TounamentScoreDetailSlice, error) <span class="cov8" title="1">{
        ctx := context.Background()

        ts, err := models.TounamentScoreDetails(search...).All(ctx, r.conn.Conn)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return ts, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>