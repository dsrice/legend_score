// Code generated by SQLBoiler 4.18.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Throw is an object representing the database table.
type Throw struct {
	// 投球ID
	ID int `boil:"id" json:"id" toml:"id" yaml:"id"`
	// ユーザーID
	UserID int `boil:"user_id" json:"user_id" toml:"user_id" yaml:"user_id"`
	// ゲームID
	GameID int `boil:"game_id" json:"game_id" toml:"game_id" yaml:"game_id"`
	// フレームID
	FrameID int `boil:"frame_id" json:"frame_id" toml:"frame_id" yaml:"frame_id"`
	// フレーム投球回数
	ThrowCount int `boil:"throw_count" json:"throw_count" toml:"throw_count" yaml:"throw_count"`
	// 投球スコア
	ThrowScore int `boil:"throw_score" json:"throw_score" toml:"throw_score" yaml:"throw_score"`
	// ストライクフラグ
	StrikeFlag bool `boil:"strike_flag" json:"strike_flag" toml:"strike_flag" yaml:"strike_flag"`
	// スペアフラグ
	SpareFlag bool `boil:"spare_flag" json:"spare_flag" toml:"spare_flag" yaml:"spare_flag"`
	// スプリットフラグ
	SplitFlag bool `boil:"split_flag" json:"split_flag" toml:"split_flag" yaml:"split_flag"`
	// 1ピン結果
	Pin1 int `boil:"pin_1" json:"pin_1" toml:"pin_1" yaml:"pin_1"`
	// 2ピン結果
	Pin2 int `boil:"pin_2" json:"pin_2" toml:"pin_2" yaml:"pin_2"`
	// 3ピン結果
	Pin3 int `boil:"pin_3" json:"pin_3" toml:"pin_3" yaml:"pin_3"`
	// 4ピン結果
	Pin4 int `boil:"pin_4" json:"pin_4" toml:"pin_4" yaml:"pin_4"`
	// 5ピン結果
	Pin5 int `boil:"pin_5" json:"pin_5" toml:"pin_5" yaml:"pin_5"`
	// 6ピン結果
	Pin6 int `boil:"pin_6" json:"pin_6" toml:"pin_6" yaml:"pin_6"`
	// 7ピン結果
	Pin7 int `boil:"pin_7" json:"pin_7" toml:"pin_7" yaml:"pin_7"`
	// 8ピン結果
	Pin8 int `boil:"pin_8" json:"pin_8" toml:"pin_8" yaml:"pin_8"`
	// 9ピン結果
	Pin9 int `boil:"pin_9" json:"pin_9" toml:"pin_9" yaml:"pin_9"`
	// 10ピン結果
	Pin10 int `boil:"pin_10" json:"pin_10" toml:"pin_10" yaml:"pin_10"`
	// 作成日
	CreatedAt time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	// 更新日
	UpdatedAt time.Time `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	// 削除フラグ
	DeletedFLG bool `boil:"deleted_flg" json:"deleted_flg" toml:"deleted_flg" yaml:"deleted_flg"`
	// 削除日
	DeletedAt null.Time `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *throwR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L throwL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ThrowColumns = struct {
	ID         string
	UserID     string
	GameID     string
	FrameID    string
	ThrowCount string
	ThrowScore string
	StrikeFlag string
	SpareFlag  string
	SplitFlag  string
	Pin1       string
	Pin2       string
	Pin3       string
	Pin4       string
	Pin5       string
	Pin6       string
	Pin7       string
	Pin8       string
	Pin9       string
	Pin10      string
	CreatedAt  string
	UpdatedAt  string
	DeletedFLG string
	DeletedAt  string
}{
	ID:         "id",
	UserID:     "user_id",
	GameID:     "game_id",
	FrameID:    "frame_id",
	ThrowCount: "throw_count",
	ThrowScore: "throw_score",
	StrikeFlag: "strike_flag",
	SpareFlag:  "spare_flag",
	SplitFlag:  "split_flag",
	Pin1:       "pin_1",
	Pin2:       "pin_2",
	Pin3:       "pin_3",
	Pin4:       "pin_4",
	Pin5:       "pin_5",
	Pin6:       "pin_6",
	Pin7:       "pin_7",
	Pin8:       "pin_8",
	Pin9:       "pin_9",
	Pin10:      "pin_10",
	CreatedAt:  "created_at",
	UpdatedAt:  "updated_at",
	DeletedFLG: "deleted_flg",
	DeletedAt:  "deleted_at",
}

var ThrowTableColumns = struct {
	ID         string
	UserID     string
	GameID     string
	FrameID    string
	ThrowCount string
	ThrowScore string
	StrikeFlag string
	SpareFlag  string
	SplitFlag  string
	Pin1       string
	Pin2       string
	Pin3       string
	Pin4       string
	Pin5       string
	Pin6       string
	Pin7       string
	Pin8       string
	Pin9       string
	Pin10      string
	CreatedAt  string
	UpdatedAt  string
	DeletedFLG string
	DeletedAt  string
}{
	ID:         "throws.id",
	UserID:     "throws.user_id",
	GameID:     "throws.game_id",
	FrameID:    "throws.frame_id",
	ThrowCount: "throws.throw_count",
	ThrowScore: "throws.throw_score",
	StrikeFlag: "throws.strike_flag",
	SpareFlag:  "throws.spare_flag",
	SplitFlag:  "throws.split_flag",
	Pin1:       "throws.pin_1",
	Pin2:       "throws.pin_2",
	Pin3:       "throws.pin_3",
	Pin4:       "throws.pin_4",
	Pin5:       "throws.pin_5",
	Pin6:       "throws.pin_6",
	Pin7:       "throws.pin_7",
	Pin8:       "throws.pin_8",
	Pin9:       "throws.pin_9",
	Pin10:      "throws.pin_10",
	CreatedAt:  "throws.created_at",
	UpdatedAt:  "throws.updated_at",
	DeletedFLG: "throws.deleted_flg",
	DeletedAt:  "throws.deleted_at",
}

// Generated where

var ThrowWhere = struct {
	ID         whereHelperint
	UserID     whereHelperint
	GameID     whereHelperint
	FrameID    whereHelperint
	ThrowCount whereHelperint
	ThrowScore whereHelperint
	StrikeFlag whereHelperbool
	SpareFlag  whereHelperbool
	SplitFlag  whereHelperbool
	Pin1       whereHelperint
	Pin2       whereHelperint
	Pin3       whereHelperint
	Pin4       whereHelperint
	Pin5       whereHelperint
	Pin6       whereHelperint
	Pin7       whereHelperint
	Pin8       whereHelperint
	Pin9       whereHelperint
	Pin10      whereHelperint
	CreatedAt  whereHelpertime_Time
	UpdatedAt  whereHelpertime_Time
	DeletedFLG whereHelperbool
	DeletedAt  whereHelpernull_Time
}{
	ID:         whereHelperint{field: "`throws`.`id`"},
	UserID:     whereHelperint{field: "`throws`.`user_id`"},
	GameID:     whereHelperint{field: "`throws`.`game_id`"},
	FrameID:    whereHelperint{field: "`throws`.`frame_id`"},
	ThrowCount: whereHelperint{field: "`throws`.`throw_count`"},
	ThrowScore: whereHelperint{field: "`throws`.`throw_score`"},
	StrikeFlag: whereHelperbool{field: "`throws`.`strike_flag`"},
	SpareFlag:  whereHelperbool{field: "`throws`.`spare_flag`"},
	SplitFlag:  whereHelperbool{field: "`throws`.`split_flag`"},
	Pin1:       whereHelperint{field: "`throws`.`pin_1`"},
	Pin2:       whereHelperint{field: "`throws`.`pin_2`"},
	Pin3:       whereHelperint{field: "`throws`.`pin_3`"},
	Pin4:       whereHelperint{field: "`throws`.`pin_4`"},
	Pin5:       whereHelperint{field: "`throws`.`pin_5`"},
	Pin6:       whereHelperint{field: "`throws`.`pin_6`"},
	Pin7:       whereHelperint{field: "`throws`.`pin_7`"},
	Pin8:       whereHelperint{field: "`throws`.`pin_8`"},
	Pin9:       whereHelperint{field: "`throws`.`pin_9`"},
	Pin10:      whereHelperint{field: "`throws`.`pin_10`"},
	CreatedAt:  whereHelpertime_Time{field: "`throws`.`created_at`"},
	UpdatedAt:  whereHelpertime_Time{field: "`throws`.`updated_at`"},
	DeletedFLG: whereHelperbool{field: "`throws`.`deleted_flg`"},
	DeletedAt:  whereHelpernull_Time{field: "`throws`.`deleted_at`"},
}

// ThrowRels is where relationship names are stored.
var ThrowRels = struct {
	Game  string
	Frame string
	User  string
}{
	Game:  "Game",
	Frame: "Frame",
	User:  "User",
}

// throwR is where relationships are stored.
type throwR struct {
	Game  *Game  `boil:"Game" json:"Game" toml:"Game" yaml:"Game"`
	Frame *Frame `boil:"Frame" json:"Frame" toml:"Frame" yaml:"Frame"`
	User  *User  `boil:"User" json:"User" toml:"User" yaml:"User"`
}

// NewStruct creates a new relationship struct
func (*throwR) NewStruct() *throwR {
	return &throwR{}
}

func (r *throwR) GetGame() *Game {
	if r == nil {
		return nil
	}
	return r.Game
}

func (r *throwR) GetFrame() *Frame {
	if r == nil {
		return nil
	}
	return r.Frame
}

func (r *throwR) GetUser() *User {
	if r == nil {
		return nil
	}
	return r.User
}

// throwL is where Load methods for each relationship are stored.
type throwL struct{}

var (
	throwAllColumns            = []string{"id", "user_id", "game_id", "frame_id", "throw_count", "throw_score", "strike_flag", "spare_flag", "split_flag", "pin_1", "pin_2", "pin_3", "pin_4", "pin_5", "pin_6", "pin_7", "pin_8", "pin_9", "pin_10", "created_at", "updated_at", "deleted_flg", "deleted_at"}
	throwColumnsWithoutDefault = []string{"user_id", "game_id", "frame_id", "throw_count", "throw_score", "pin_1", "pin_2", "pin_3", "pin_4", "pin_5", "pin_6", "pin_7", "pin_8", "pin_9", "pin_10", "deleted_at"}
	throwColumnsWithDefault    = []string{"id", "strike_flag", "spare_flag", "split_flag", "created_at", "updated_at", "deleted_flg"}
	throwPrimaryKeyColumns     = []string{"id"}
	throwGeneratedColumns      = []string{}
)

type (
	// ThrowSlice is an alias for a slice of pointers to Throw.
	// This should almost always be used instead of []Throw.
	ThrowSlice []*Throw
	// ThrowHook is the signature for custom Throw hook methods
	ThrowHook func(context.Context, boil.ContextExecutor, *Throw) error

	throwQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	throwType                 = reflect.TypeOf(&Throw{})
	throwMapping              = queries.MakeStructMapping(throwType)
	throwPrimaryKeyMapping, _ = queries.BindMapping(throwType, throwMapping, throwPrimaryKeyColumns)
	throwInsertCacheMut       sync.RWMutex
	throwInsertCache          = make(map[string]insertCache)
	throwUpdateCacheMut       sync.RWMutex
	throwUpdateCache          = make(map[string]updateCache)
	throwUpsertCacheMut       sync.RWMutex
	throwUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var throwAfterSelectMu sync.Mutex
var throwAfterSelectHooks []ThrowHook

var throwBeforeInsertMu sync.Mutex
var throwBeforeInsertHooks []ThrowHook
var throwAfterInsertMu sync.Mutex
var throwAfterInsertHooks []ThrowHook

var throwBeforeUpdateMu sync.Mutex
var throwBeforeUpdateHooks []ThrowHook
var throwAfterUpdateMu sync.Mutex
var throwAfterUpdateHooks []ThrowHook

var throwBeforeDeleteMu sync.Mutex
var throwBeforeDeleteHooks []ThrowHook
var throwAfterDeleteMu sync.Mutex
var throwAfterDeleteHooks []ThrowHook

var throwBeforeUpsertMu sync.Mutex
var throwBeforeUpsertHooks []ThrowHook
var throwAfterUpsertMu sync.Mutex
var throwAfterUpsertHooks []ThrowHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Throw) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Throw) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Throw) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Throw) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Throw) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Throw) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Throw) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Throw) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Throw) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range throwAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddThrowHook registers your hook function for all future operations.
func AddThrowHook(hookPoint boil.HookPoint, throwHook ThrowHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		throwAfterSelectMu.Lock()
		throwAfterSelectHooks = append(throwAfterSelectHooks, throwHook)
		throwAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		throwBeforeInsertMu.Lock()
		throwBeforeInsertHooks = append(throwBeforeInsertHooks, throwHook)
		throwBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		throwAfterInsertMu.Lock()
		throwAfterInsertHooks = append(throwAfterInsertHooks, throwHook)
		throwAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		throwBeforeUpdateMu.Lock()
		throwBeforeUpdateHooks = append(throwBeforeUpdateHooks, throwHook)
		throwBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		throwAfterUpdateMu.Lock()
		throwAfterUpdateHooks = append(throwAfterUpdateHooks, throwHook)
		throwAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		throwBeforeDeleteMu.Lock()
		throwBeforeDeleteHooks = append(throwBeforeDeleteHooks, throwHook)
		throwBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		throwAfterDeleteMu.Lock()
		throwAfterDeleteHooks = append(throwAfterDeleteHooks, throwHook)
		throwAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		throwBeforeUpsertMu.Lock()
		throwBeforeUpsertHooks = append(throwBeforeUpsertHooks, throwHook)
		throwBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		throwAfterUpsertMu.Lock()
		throwAfterUpsertHooks = append(throwAfterUpsertHooks, throwHook)
		throwAfterUpsertMu.Unlock()
	}
}

// One returns a single throw record from the query.
func (q throwQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Throw, error) {
	o := &Throw{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for throws")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Throw records from the query.
func (q throwQuery) All(ctx context.Context, exec boil.ContextExecutor) (ThrowSlice, error) {
	var o []*Throw

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Throw slice")
	}

	if len(throwAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Throw records in the query.
func (q throwQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count throws rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q throwQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if throws exists")
	}

	return count > 0, nil
}

// Game pointed to by the foreign key.
func (o *Throw) Game(mods ...qm.QueryMod) gameQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.GameID),
	}

	queryMods = append(queryMods, mods...)

	return Games(queryMods...)
}

// Frame pointed to by the foreign key.
func (o *Throw) Frame(mods ...qm.QueryMod) frameQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.FrameID),
	}

	queryMods = append(queryMods, mods...)

	return Frames(queryMods...)
}

// User pointed to by the foreign key.
func (o *Throw) User(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.UserID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// LoadGame allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (throwL) LoadGame(ctx context.Context, e boil.ContextExecutor, singular bool, maybeThrow interface{}, mods queries.Applicator) error {
	var slice []*Throw
	var object *Throw

	if singular {
		var ok bool
		object, ok = maybeThrow.(*Throw)
		if !ok {
			object = new(Throw)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeThrow)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeThrow))
			}
		}
	} else {
		s, ok := maybeThrow.(*[]*Throw)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeThrow)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeThrow))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &throwR{}
		}
		args[object.GameID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &throwR{}
			}

			args[obj.GameID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`games`),
		qm.WhereIn(`games.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Game")
	}

	var resultSlice []*Game
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Game")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for games")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for games")
	}

	if len(gameAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Game = foreign
		if foreign.R == nil {
			foreign.R = &gameR{}
		}
		foreign.R.Throws = append(foreign.R.Throws, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.GameID == foreign.ID {
				local.R.Game = foreign
				if foreign.R == nil {
					foreign.R = &gameR{}
				}
				foreign.R.Throws = append(foreign.R.Throws, local)
				break
			}
		}
	}

	return nil
}

// LoadFrame allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (throwL) LoadFrame(ctx context.Context, e boil.ContextExecutor, singular bool, maybeThrow interface{}, mods queries.Applicator) error {
	var slice []*Throw
	var object *Throw

	if singular {
		var ok bool
		object, ok = maybeThrow.(*Throw)
		if !ok {
			object = new(Throw)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeThrow)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeThrow))
			}
		}
	} else {
		s, ok := maybeThrow.(*[]*Throw)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeThrow)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeThrow))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &throwR{}
		}
		args[object.FrameID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &throwR{}
			}

			args[obj.FrameID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`frames`),
		qm.WhereIn(`frames.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Frame")
	}

	var resultSlice []*Frame
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Frame")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for frames")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for frames")
	}

	if len(frameAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Frame = foreign
		if foreign.R == nil {
			foreign.R = &frameR{}
		}
		foreign.R.Throws = append(foreign.R.Throws, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FrameID == foreign.ID {
				local.R.Frame = foreign
				if foreign.R == nil {
					foreign.R = &frameR{}
				}
				foreign.R.Throws = append(foreign.R.Throws, local)
				break
			}
		}
	}

	return nil
}

// LoadUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (throwL) LoadUser(ctx context.Context, e boil.ContextExecutor, singular bool, maybeThrow interface{}, mods queries.Applicator) error {
	var slice []*Throw
	var object *Throw

	if singular {
		var ok bool
		object, ok = maybeThrow.(*Throw)
		if !ok {
			object = new(Throw)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeThrow)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeThrow))
			}
		}
	} else {
		s, ok := maybeThrow.(*[]*Throw)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeThrow)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeThrow))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &throwR{}
		}
		args[object.UserID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &throwR{}
			}

			args[obj.UserID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(userAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.User = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.Throws = append(foreign.R.Throws, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.UserID == foreign.ID {
				local.R.User = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.Throws = append(foreign.R.Throws, local)
				break
			}
		}
	}

	return nil
}

// SetGame of the throw to the related item.
// Sets o.R.Game to related.
// Adds o to related.R.Throws.
func (o *Throw) SetGame(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Game) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `throws` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"game_id"}),
		strmangle.WhereClause("`", "`", 0, throwPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.GameID = related.ID
	if o.R == nil {
		o.R = &throwR{
			Game: related,
		}
	} else {
		o.R.Game = related
	}

	if related.R == nil {
		related.R = &gameR{
			Throws: ThrowSlice{o},
		}
	} else {
		related.R.Throws = append(related.R.Throws, o)
	}

	return nil
}

// SetFrame of the throw to the related item.
// Sets o.R.Frame to related.
// Adds o to related.R.Throws.
func (o *Throw) SetFrame(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Frame) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `throws` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"frame_id"}),
		strmangle.WhereClause("`", "`", 0, throwPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FrameID = related.ID
	if o.R == nil {
		o.R = &throwR{
			Frame: related,
		}
	} else {
		o.R.Frame = related
	}

	if related.R == nil {
		related.R = &frameR{
			Throws: ThrowSlice{o},
		}
	} else {
		related.R.Throws = append(related.R.Throws, o)
	}

	return nil
}

// SetUser of the throw to the related item.
// Sets o.R.User to related.
// Adds o to related.R.Throws.
func (o *Throw) SetUser(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `throws` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"user_id"}),
		strmangle.WhereClause("`", "`", 0, throwPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.UserID = related.ID
	if o.R == nil {
		o.R = &throwR{
			User: related,
		}
	} else {
		o.R.User = related
	}

	if related.R == nil {
		related.R = &userR{
			Throws: ThrowSlice{o},
		}
	} else {
		related.R.Throws = append(related.R.Throws, o)
	}

	return nil
}

// Throws retrieves all the records using an executor.
func Throws(mods ...qm.QueryMod) throwQuery {
	mods = append(mods, qm.From("`throws`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`throws`.*"})
	}

	return throwQuery{q}
}

// FindThrow retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindThrow(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Throw, error) {
	throwObj := &Throw{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `throws` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, throwObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from throws")
	}

	if err = throwObj.doAfterSelectHooks(ctx, exec); err != nil {
		return throwObj, err
	}

	return throwObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Throw) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no throws provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(throwColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	throwInsertCacheMut.RLock()
	cache, cached := throwInsertCache[key]
	throwInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			throwAllColumns,
			throwColumnsWithDefault,
			throwColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(throwType, throwMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(throwType, throwMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `throws` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `throws` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `throws` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, throwPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into throws")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == throwMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for throws")
	}

CacheNoHooks:
	if !cached {
		throwInsertCacheMut.Lock()
		throwInsertCache[key] = cache
		throwInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Throw.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Throw) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	throwUpdateCacheMut.RLock()
	cache, cached := throwUpdateCache[key]
	throwUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			throwAllColumns,
			throwPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update throws, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `throws` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, throwPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(throwType, throwMapping, append(wl, throwPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update throws row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for throws")
	}

	if !cached {
		throwUpdateCacheMut.Lock()
		throwUpdateCache[key] = cache
		throwUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q throwQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for throws")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for throws")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ThrowSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), throwPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `throws` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, throwPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in throw slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all throw")
	}
	return rowsAff, nil
}

var mySQLThrowUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Throw) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no throws provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(throwColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLThrowUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	throwUpsertCacheMut.RLock()
	cache, cached := throwUpsertCache[key]
	throwUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			throwAllColumns,
			throwColumnsWithDefault,
			throwColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			throwAllColumns,
			throwPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert throws, could not build update column list")
		}

		ret := strmangle.SetComplement(throwAllColumns, strmangle.SetIntersect(insert, update))

		cache.query = buildUpsertQueryMySQL(dialect, "`throws`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `throws` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(throwType, throwMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(throwType, throwMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for throws")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == throwMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(throwType, throwMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for throws")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for throws")
	}

CacheNoHooks:
	if !cached {
		throwUpsertCacheMut.Lock()
		throwUpsertCache[key] = cache
		throwUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Throw record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Throw) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Throw provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), throwPrimaryKeyMapping)
	sql := "DELETE FROM `throws` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from throws")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for throws")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q throwQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no throwQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from throws")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for throws")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ThrowSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(throwBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), throwPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `throws` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, throwPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from throw slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for throws")
	}

	if len(throwAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Throw) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindThrow(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ThrowSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ThrowSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), throwPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `throws`.* FROM `throws` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, throwPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ThrowSlice")
	}

	*o = slice

	return nil
}

// ThrowExists checks if the Throw row exists.
func ThrowExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `throws` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if throws exists")
	}

	return exists, nil
}

// Exists checks if the Throw row exists.
func (o *Throw) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return ThrowExists(ctx, exec, o.ID)
}
